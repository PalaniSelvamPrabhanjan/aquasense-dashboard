import json
import os
import boto3
from decimal import Decimal
from boto3.dynamodb.conditions import Key

dynamodb = boto3.resource("dynamodb")
TABLE_NAME = os.environ.get("FEEDING_EVENTS_TABLE", "aquascope_feeding_events")
ALLOWED_ORIGIN = os.environ.get("ALLOWED_ORIGIN", "*")

table = dynamodb.Table(TABLE_NAME)

def _resp(status, body=None, extra_headers=None):
    headers = {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": ALLOWED_ORIGIN,
        "Access-Control-Allow-Headers": "content-type",
        "Access-Control-Allow-Methods": "GET,POST,OPTIONS"
    }
    if extra_headers:
        headers.update(extra_headers)
    return {"statusCode": status, "headers": headers, "body": json.dumps(body or {})}

def _to_decimal(val):
    if val is None:
        return None
    if isinstance(val, (int, float, Decimal)):
        return Decimal(str(val))
    return Decimal(str(val))

def lambda_handler(event, context):
    method = event.get("requestContext", {}).get("http", {}).get("method") or event.get("httpMethod")

    if method == "OPTIONS":
        return _resp(200, {"ok": True})

    if method == "GET":
        qs = event.get("queryStringParameters") or {}
        tank_id = qs.get("tank_id")
        if not tank_id:
            return _resp(400, {"error": "Missing query param: tank_id"})

        limit = int(qs.get("limit", 20))
        # Optional time range
        start_ts = qs.get("start_ts")  # ISO string
        end_ts = qs.get("end_ts")      # ISO string

        key_expr = Key("tank_id").eq(tank_id)
        if start_ts and end_ts:
            key_expr = key_expr & Key("timestamp").between(start_ts, end_ts)

        r = table.query(
            KeyConditionExpression=key_expr,
            ScanIndexForward=False,  # latest first
            Limit=limit
        )

        items = r.get("Items", [])
        # Convert Decimal to float
        for it in items:
            for k, v in list(it.items()):
                if isinstance(v, Decimal):
                    it[k] = float(v)

        return _resp(200, {"tank_id": tank_id, "count": len(items), "items": items})

    if method == "POST":
        raw = event.get("body") or "{}"
        try:
            body = json.loads(raw)
        except json.JSONDecodeError:
            return _resp(400, {"error": "Invalid JSON body"})

        tank_id = body.get("tank_id")
        timestamp = body.get("timestamp")  # REQUIRED for sort key
        if not tank_id or not timestamp:
            return _resp(400, {"error": "Missing fields: tank_id and timestamp (ISO string)"})

        item = {
            "tank_id": tank_id,
            "timestamp": timestamp,
            "event_type": body.get("event_type", "SCHEDULE_UPDATED"),
            "feed_time": body.get("feed_time"),  # "19:00"
            "feed_quantity_g": _to_decimal(body.get("feed_quantity_g")),
            "notes": body.get("notes")
        }

        # Remove None values
        item = {k: v for k, v in item.items() if v is not None}

        table.put_item(Item=item)
        return _resp(200, {"message": "Saved feeding event", "tank_id": tank_id, "timestamp": timestamp})

    return _resp(405, {"error": f"Method not allowed: {method}"})
